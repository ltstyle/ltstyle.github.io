(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{764:function(a,t,s){"use strict";s.r(t);var r=s(1),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"html篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html篇"}},[a._v("#")]),a._v(" HTML篇")]),a._v(" "),s("h4",{attrs:{id:"_1-对html语义化的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-对html语义化的理解"}},[a._v("#")]),a._v(" 1. 对html语义化的理解")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("HTML5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如nav表示导航条，类似的还有article、header、footer等等标签。\n")])])]),s("h4",{attrs:{id:"_2-html5有哪些更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-html5有哪些更新"}},[a._v("#")]),a._v(" 2. html5有哪些更新")]),a._v(" "),s("h4",{attrs:{id:"_3-src和href的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-src和href的区别"}},[a._v("#")]),a._v(" 3. src和href的区别")]),a._v(" "),s("h4",{attrs:{id:"_4-行内-块级元素有哪些-空-void-元素有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-行内-块级元素有哪些-空-void-元素有哪些"}},[a._v("#")]),a._v(" 4. 行内/块级元素有哪些？空(void)元素有哪些")]),a._v(" "),s("h4",{attrs:{id:"_5-script标签中defer和async的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-script标签中defer和async的区别"}},[a._v("#")]),a._v(" 5. script标签中defer和async的区别")]),a._v(" "),s("h2",{attrs:{id:"css篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css篇"}},[a._v("#")]),a._v(" CSS篇")]),a._v(" "),s("h3",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),s("h4",{attrs:{id:"_1-css选择器及其优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-css选择器及其优先级"}},[a._v("#")]),a._v(" 1. css选择器及其优先级")]),a._v(" "),s("h4",{attrs:{id:"_2-display的属性及其作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-display的属性及其作用"}},[a._v("#")]),a._v(" 2. display的属性及其作用")]),a._v(" "),s("h4",{attrs:{id:"_3-display的block、inline和inline-block的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-display的block、inline和inline-block的区别"}},[a._v("#")]),a._v(" 3. display的block、inline和inline-block的区别")]),a._v(" "),s("h4",{attrs:{id:"_4-display-none与visibility-hidden的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-display-none与visibility-hidden的区别"}},[a._v("#")]),a._v(" 4. display:none与visibility:hidden的区别")]),a._v(" "),s("h4",{attrs:{id:"_5-对盒模型的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-对盒模型的理解"}},[a._v("#")]),a._v(" 5. 对盒模型的理解")]),a._v(" "),s("h4",{attrs:{id:"_6-css3中有哪些新特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-css3中有哪些新特性"}},[a._v("#")]),a._v(" 6. css3中有哪些新特性")]),a._v(" "),s("h4",{attrs:{id:"_7-单行、多行文本溢出隐藏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-单行、多行文本溢出隐藏"}},[a._v("#")]),a._v(" 7. 单行、多行文本溢出隐藏")]),a._v(" "),s("h3",{attrs:{id:"页面布局"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#页面布局"}},[a._v("#")]),a._v(" 页面布局")]),a._v(" "),s("h4",{attrs:{id:"_8-两栏布局的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-两栏布局的实现"}},[a._v("#")]),a._v(" 8. 两栏布局的实现")]),a._v(" "),s("h4",{attrs:{id:"_9-三栏布局的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-三栏布局的实现"}},[a._v("#")]),a._v(" 9. 三栏布局的实现")]),a._v(" "),s("h4",{attrs:{id:"_10-水平垂直居中的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-水平垂直居中的实现"}},[a._v("#")]),a._v(" 10. 水平垂直居中的实现")]),a._v(" "),s("h4",{attrs:{id:"_11-对flex布局的理解及其使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-对flex布局的理解及其使用场景"}},[a._v("#")]),a._v(" 11. 对Flex布局的理解及其使用场景")]),a._v(" "),s("h3",{attrs:{id:"定位浮动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定位浮动"}},[a._v("#")]),a._v(" 定位浮动")]),a._v(" "),s("h4",{attrs:{id:"_12-为什么需要清除浮动-清除浮动的方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-为什么需要清除浮动-清除浮动的方式"}},[a._v("#")]),a._v(" 12. 为什么需要清除浮动？清除浮动的方式")]),a._v(" "),s("h4",{attrs:{id:"_13-对bfc的理解-如何创建bfc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-对bfc的理解-如何创建bfc"}},[a._v("#")]),a._v(" 13. 对BFC的理解，如何创建BFC")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。\n在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。\nW3C CSS 2.1中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。\n")])])]),s("h4",{attrs:{id:"_14-position的属性有哪些。区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-position的属性有哪些。区别是什么"}},[a._v("#")]),a._v(" 14. position的属性有哪些。区别是什么")]),a._v(" "),s("h3",{attrs:{id:"场景应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景应用"}},[a._v("#")]),a._v(" 场景应用")]),a._v(" "),s("h4",{attrs:{id:"_15-实现一个三角形"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-实现一个三角形"}},[a._v("#")]),a._v(" 15. 实现一个三角形")]),a._v(" "),s("h4",{attrs:{id:"_16-如何解决1px的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-如何解决1px的问题"}},[a._v("#")]),a._v(" 16. 如何解决1px的问题")]),a._v(" "),s("h2",{attrs:{id:"js篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js篇"}},[a._v("#")]),a._v(" JS篇")]),a._v(" "),s("h3",{attrs:{id:"基础-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础-2"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),s("h4",{attrs:{id:"_1-new操作符的实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-new操作符的实现原理"}},[a._v("#")]),a._v(" 1. new操作符的实现原理")]),a._v(" "),s("h4",{attrs:{id:"_2-数组有哪些原生方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-数组有哪些原生方法"}},[a._v("#")]),a._v(" 2. 数组有哪些原生方法")]),a._v(" "),s("h4",{attrs:{id:"_3-什么是dom和bom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-什么是dom和bom"}},[a._v("#")]),a._v(" 3. 什么是DOM和BOM?")]),a._v(" "),s("h4",{attrs:{id:"_4-对类数组对象的理解-如何转化为数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-对类数组对象的理解-如何转化为数组"}},[a._v("#")]),a._v(" 4. 对类数组对象的理解，如何转化为数组")]),a._v(" "),s("h4",{attrs:{id:"_5-对ajax的理解-实现一个ajax请求"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-对ajax的理解-实现一个ajax请求"}},[a._v("#")]),a._v(" 5. 对AJAX的理解，实现一个AJAX请求")]),a._v(" "),s("h4",{attrs:{id:"_6-js为什么要进行变量提升-它导致了什么问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-js为什么要进行变量提升-它导致了什么问题"}},[a._v("#")]),a._v(" 6. js为什么要进行变量提升，它导致了什么问题")]),a._v(" "),s("h3",{attrs:{id:"数据类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[a._v("#")]),a._v(" 数据类型")]),a._v(" "),s("h4",{attrs:{id:"_7-js有哪些数据类型-他们的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-js有哪些数据类型-他们的区别"}},[a._v("#")]),a._v(" 7. js有哪些数据类型，他们的区别？")]),a._v(" "),s("h4",{attrs:{id:"_8-数据类型检测的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-数据类型检测的方式有哪些"}},[a._v("#")]),a._v(" 8. 数据类型检测的方式有哪些")]),a._v(" "),s("h4",{attrs:{id:"_9-判断数组的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-判断数组的方式有哪些"}},[a._v("#")]),a._v(" 9. 判断数组的方式有哪些")]),a._v(" "),s("h4",{attrs:{id:"_10-null和undefined区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-null和undefined区别"}},[a._v("#")]),a._v(" 10. null和undefined区别")]),a._v(" "),s("h4",{attrs:{id:"_11-intanceof操作符的实现及原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-intanceof操作符的实现及原理"}},[a._v("#")]),a._v(" 11. intanceof操作符的实现及原理")]),a._v(" "),s("h4",{attrs:{id:"_12-为什么0-1-0-2-0-3-如何让其相等"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-为什么0-1-0-2-0-3-如何让其相等"}},[a._v("#")]),a._v(" 12. 为什么0.1+0.2!==0.3,如何让其相等")]),a._v(" "),s("h4",{attrs:{id:"_13-操作符的强制类型转换规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-操作符的强制类型转换规则"}},[a._v("#")]),a._v(" 13. ==操作符的强制类型转换规则")]),a._v(" "),s("h4",{attrs:{id:"_14-object-is-与比较操作符-、-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-object-is-与比较操作符-、-的区别"}},[a._v("#")]),a._v(" 14. Object.is()与比较操作符“===”、“==”的区别")]),a._v(" "),s("h3",{attrs:{id:"es6"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[a._v("#")]),a._v(" ES6")]),a._v(" "),s("h4",{attrs:{id:"_15-let、const、var的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-let、const、var的区别"}},[a._v("#")]),a._v(" 15. let、const、var的区别")]),a._v(" "),s("h4",{attrs:{id:"_16-箭头函数与普通函数的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-箭头函数与普通函数的区别"}},[a._v("#")]),a._v(" 16. 箭头函数与普通函数的区别")]),a._v(" "),s("h3",{attrs:{id:"原型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[a._v("#")]),a._v(" 原型")]),a._v(" "),s("h4",{attrs:{id:"_17-对原型、原型链的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-对原型、原型链的理解"}},[a._v("#")]),a._v(" 17. 对原型、原型链的理解")]),a._v(" "),s("h4",{attrs:{id:"_18-原型链指向"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-原型链指向"}},[a._v("#")]),a._v(" 18. 原型链指向")]),a._v(" "),s("h3",{attrs:{id:"异步编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步编程"}},[a._v("#")]),a._v(" 异步编程")]),a._v(" "),s("h4",{attrs:{id:"_19-对promise的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-对promise的理解"}},[a._v("#")]),a._v(" 19. 对promise的理解")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("它是什么？\nPromise是一个方案，用来解决多层回调嵌套的解决方案。它现在是ES6的原生对象。\n干嘛用的？\n可以把一个多层嵌套的同步、异步都有回调的方法，给拉直为一串.then()组成的调用链。\n解决啥问题？\n多层嵌套的回调方法中，如果同时存在同步、异步的方法，那么实际执行顺序会混乱。不好调试不好维护。\n")])])]),s("h4",{attrs:{id:"_20-promise基本用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-promise基本用法"}},[a._v("#")]),a._v(" 20. promise基本用法")]),a._v(" "),s("h4",{attrs:{id:"_21-对async-await的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-对async-await的理解"}},[a._v("#")]),a._v(" 21. 对async/await的理解")]),a._v(" "),s("h4",{attrs:{id:"_22-async-await对比promise的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-async-await对比promise的优势"}},[a._v("#")]),a._v(" 22. async/await对比promise的优势")]),a._v(" "),s("h3",{attrs:{id:"其他"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[a._v("#")]),a._v(" 其他")]),a._v(" "),s("h4",{attrs:{id:"_23-对闭包的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_23-对闭包的理解"}},[a._v("#")]),a._v(" 23. 对闭包的理解")]),a._v(" "),s("h4",{attrs:{id:"_24-对作用域、作用域链的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_24-对作用域、作用域链的理解"}},[a._v("#")]),a._v(" 24. 对作用域、作用域链的理解")]),a._v(" "),s("h4",{attrs:{id:"_25-对执行上下文的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_25-对执行上下文的理解"}},[a._v("#")]),a._v(" 25. 对执行上下文的理解")]),a._v(" "),s("h4",{attrs:{id:"_26-对this的对象的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_26-对this的对象的理解"}},[a._v("#")]),a._v(" 26. 对this的对象的理解")]),a._v(" "),s("h4",{attrs:{id:"_27-call-和apply-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_27-call-和apply-的区别"}},[a._v("#")]),a._v(" 27. call()和apply()的区别")]),a._v(" "),s("h4",{attrs:{id:"_28-浏览器垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_28-浏览器垃圾回收机制"}},[a._v("#")]),a._v(" 28. 浏览器垃圾回收机制")]),a._v(" "),s("h2",{attrs:{id:"vue篇"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue篇"}},[a._v("#")]),a._v(" VUE篇")]),a._v(" "),s("h3",{attrs:{id:"基础-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础-3"}},[a._v("#")]),a._v(" 基础")]),a._v(" "),s("h4",{attrs:{id:"_1-vue的基本原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-vue的基本原理"}},[a._v("#")]),a._v(" 1. Vue的基本原理")]),a._v(" "),s("h4",{attrs:{id:"_2-双向数据绑定的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-双向数据绑定的原理"}},[a._v("#")]),a._v(" 2. 双向数据绑定的原理")]),a._v(" "),s("h4",{attrs:{id:"_3-mvc、mvvm、mvp的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-mvc、mvvm、mvp的区别"}},[a._v("#")]),a._v(" 3. MVC、MVVM、MVP的区别")]),a._v(" "),s("h4",{attrs:{id:"_4-computed和watch的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-computed和watch的区别"}},[a._v("#")]),a._v(" 4. Computed和Watch的区别")]),a._v(" "),s("h4",{attrs:{id:"_5-computed和methods的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-computed和methods的区别"}},[a._v("#")]),a._v(" 5. Computed和Methods的区别")]),a._v(" "),s("h4",{attrs:{id:"_6-v-if和v-show的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-v-if和v-show的区别"}},[a._v("#")]),a._v(" 6. v-if和v-show的区别")]),a._v(" "),s("h4",{attrs:{id:"_7-data为什么是一个函数二不是对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-data为什么是一个函数二不是对象"}},[a._v("#")]),a._v(" 7. data为什么是一个函数二不是对象")]),a._v(" "),s("h4",{attrs:{id:"_8-单页面应用于多页面应用的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-单页面应用于多页面应用的区别"}},[a._v("#")]),a._v(" 8. 单页面应用于多页面应用的区别")]),a._v(" "),s("h4",{attrs:{id:"_9-对spa单页面的理解-它的优缺点分别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-对spa单页面的理解-它的优缺点分别是什么"}},[a._v("#")]),a._v(" 9. 对SPA单页面的理解，它的优缺点分别是什么")]),a._v(" "),s("h4",{attrs:{id:"_10-react和vue的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-react和vue的区别"}},[a._v("#")]),a._v(" 10. React和Vue的区别")]),a._v(" "),s("h4",{attrs:{id:"_11-vue的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue的优点"}},[a._v("#")]),a._v(" 11. Vue的优点")]),a._v(" "),s("h3",{attrs:{id:"生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[a._v("#")]),a._v(" 生命周期")]),a._v(" "),s("h4",{attrs:{id:"_12-简单说一下vue的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12-简单说一下vue的生命周期"}},[a._v("#")]),a._v(" 12. 简单说一下Vue的生命周期")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[a._v("Vue实例有一个完整的生命周期 也就是从开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程\n我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。\n每一个组件或者实例都会经历一个完整的生命周期，总共分为三个阶段：初始化、运行中、销毁。\n")])])]),s("h3",{attrs:{id:"组件通信"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件通信"}},[a._v("#")]),a._v(" 组件通信")]),a._v(" "),s("h4",{attrs:{id:"_13-组件通信的方式有哪些"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-组件通信的方式有哪些"}},[a._v("#")]),a._v(" 13. 组件通信的方式有哪些")]),a._v(" "),s("h3",{attrs:{id:"路由"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#路由"}},[a._v("#")]),a._v(" 路由")]),a._v(" "),s("h4",{attrs:{id:"_14-路由的hash和history"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-路由的hash和history"}},[a._v("#")]),a._v(" 14. 路由的hash和history")]),a._v(" "),s("h4",{attrs:{id:"_15-对前端路由的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15-对前端路由的理解"}},[a._v("#")]),a._v(" 15. 对前端路由的理解")]),a._v(" "),s("h3",{attrs:{id:"vuex"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[a._v("#")]),a._v(" Vuex")]),a._v(" "),s("h4",{attrs:{id:"_16-vuex的原理以及自己的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-vuex的原理以及自己的理解"}},[a._v("#")]),a._v(" 16. Vuex的原理以及自己的理解")]),a._v(" "),s("h4",{attrs:{id:"_17-action和mutation的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_17-action和mutation的区别"}},[a._v("#")]),a._v(" 17. action和mutation的区别")]),a._v(" "),s("h4",{attrs:{id:"_18-redux和vuex有什么区别-它们的共同思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_18-redux和vuex有什么区别-它们的共同思想"}},[a._v("#")]),a._v(" 18. Redux和Vuex有什么区别，它们的共同思想")]),a._v(" "),s("h3",{attrs:{id:"vue-3-0"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-3-0"}},[a._v("#")]),a._v(" Vue 3.0")]),a._v(" "),s("h4",{attrs:{id:"_19-vue3-0有什么更新"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_19-vue3-0有什么更新"}},[a._v("#")]),a._v(" 19. Vue3.0有什么更新")]),a._v(" "),s("h4",{attrs:{id:"_20-defineproperty和proxy的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_20-defineproperty和proxy的区别"}},[a._v("#")]),a._v(" 20. defineProperty和proxy的区别")]),a._v(" "),s("h3",{attrs:{id:"虚拟dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[a._v("#")]),a._v(" 虚拟DOM")]),a._v(" "),s("h4",{attrs:{id:"_21-对虚拟dom的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-对虚拟dom的理解"}},[a._v("#")]),a._v(" 21. 对虚拟DOM的理解")]),a._v(" "),s("h4",{attrs:{id:"_22-diff算法的原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_22-diff算法的原理"}},[a._v("#")]),a._v(" 22. diff算法的原理")])])}),[],!1,null,null,null);t.default=e.exports}}]);